import PIL 
import numpy as np
import cv2
import csv
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image
from os import listdir
from scipy import ndimage, misc
from os.path import isfile, join

def loadImages(path):
    readfile = [f for f in listdir(path) if isfile(join(path,f)) ]
    images = np.empty(len(readfile), dtype=object)
    for n in range(0, len(readfile)):
        images[n] = cv2.imread(join(path, readfile[n]))
    return images

def assignLabels(array, label, size):
    vector = np.zeros(len(array), dtype = int)
    for x in range(len(vector)):
        vector[x] = label
    return vector

def BGRtoRGB(images):
    newImages = images
    for i in range(len(images)):
        temp = Image.fromarray(images[i])
        b, g, r = temp.split()
        temp = Image.merge("RGB", (r,g,b))
        newImages[i] = np.array(temp)
    return newImages

def sRGBtoLinear(x):
    if (x < 0.04045): 
        return x/12.92
    return pow((x+0.055)/1.055, 2.4)

def LineartosRGB(y): 
    if (y <= 0.0031308): 
        return 12.92 * y
    return 1.055 * pow(y, 1/2.4) - 0.055

def RGBtoGreyscale(images):
    greyscale = images
    
    for i in range(len(images)):
        temp = Image.fromarray(images[i])
        b, g, r = temp.split()
        R = np.array(r)
        G = np.array(g)
        B = np.array(b)
        
        R_linear = np.zeros((len(R[:,0]), len(R[0,:])), dtype = float)
        G_linear = np.zeros((len(G[:,0]), len(G[0,:])), dtype = float)
        B_linear = np.zeros((len(B[:,0]), len(B[0,:])), dtype = float)
        Gray_linear = np.zeros((len(B[:,0]), len(B[0,:])), dtype = float)
        Gray_Color = np.zeros((len(B[:,0]), len(B[0,:])), dtype = int)
        
        for j in range(len(R[:,0])-1):
            for k in range(len(R[0,:])-1):
                R_linear[j][k] =sRGBtoLinear((R[j][k])/255.0)
                G_linear[j][k] =sRGBtoLinear((G[j][k])/255.0)
                B_linear[j][k] =sRGBtoLinear((B[j][k])/255.0)
                
                Gray_linear[j][k] = 0.2126 * R_linear[j][k] + 0.7152 * G_linear[j][k] + 0.0722 * B_linear[j][k]
                Gray_Color[j][k] = int(LineartosRGB(Gray_linear[j][k]) * 255)

        greyscale[i] = np.array(Gray_Color)
    return greyscale

def findMaxWidth(images):
    Max = 0
    for i in range(len(images)):
        size = images[i].shape
        if(size[0] > Max):
            Max = size[0]
    return Max

def findMaxLenght(images):
    Max = 0
    for i in range(len(images)):
        size = images[i].shape
        if(size[1] > Max):
            Max = size[1]
    return Max

def zeroPadding(images):
    maxw = findMaxWidth(images)
    maxl = findMaxLenght(images)
    result = np.zeros((len(images),maxl,maxw), dtype=np.uint8)
    
    for i in range(len(images)):
        img = images[i]
        lenght, width= img.shape

        # create new image of desired size and color (blue) for padding
        ww = 300
        hh = 300

        # compute center offset
        xpos = (maxw - width) // 2
        ypos = (maxl - lenght) // 2

        # copy img image into center of result image
        result[i, ypos:ypos+lenght, xpos:xpos+width] = img
    return result

def saveCSV(filename, dataset)
    
#Location of images on my computer, will be different for yours
path = 'C:\\Users\\\Athena\\Desktop\\101_ObjectCategories\\'
#Type of images we want to work on -- accordion in this case
subPath1 = 'accordion\\'

#Full file location
fileLoc1 = (path + subPath1)

images1 = loadImages(fileLoc1)

color_images = BGRtoRGB(images1)

gray_images = RGBtoGreyscale(color_images)

zero_padded = zeroPadding(gray_images)

max_width = findMaxWidth(gray_images)
max_lenght = findMaxLenght(gray_images)
features = np.zeros((len(zero_padded),(max_width * max_lenght)), dtype = int)
for i in range(len(zero_padded) - 1):
    features[i] = np.ravel(zero_padded[i])
